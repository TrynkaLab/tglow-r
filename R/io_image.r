#-------------------------------------------------------------------------------
#' Build an index of where the source images are stored
#'
#' @description
#' This assumes images are organized as follows:
#' <plate>/<row>/<col>/<field>.ome.tiff
#'
#' Matches images based on <plate>/<row>/<col>/<field>.ome.tiff
#'
#' @param path path to tglow image dir
#' @param plate_filter plate names to run
#' @param pattern the pattern to match image names and then extract the fields (gsubbed away)
#'
#' @returns A data frame with the image paths
#' @export
tglow_build_img_index <- function(path, plate_filter = NULL, pattern = ".ome.tiff$") {
    plates <- list.files(path, recursive = F)

    if (!is.null(plate_filter)) {
        plates <- plates[plates %in% plate_filter]
    }

    # cat("[INFO] Indexing plates: ", plates, "\n")

    index <- data.frame(matrix(NA, nrow = 0, ncol = 6))

    nfiles <- 0
    for (plate in plates) {
        cat("[INFO] Indexing plate: ", plate, "\n")

        rows <- list.files(paste0(path, "/", plate), pattern = "^[A-Z]$")
        for (row in rows) {
            cols <- list.files(paste0(path, "/", plate, "/", row), pattern = "^\\d+$")
            for (col in cols) {
                files <- list.files(paste0(path, "/", plate, "/", row, "/", col), pattern = pattern)
                nfiles <- nfiles + length(files)
                for (file in files) {
                    field <- gsub(pattern, "", file)
                    tmp <- c(plate, paste0(row, sprintf("%02d", as.numeric(col))), row, col, field, paste0(path, "/", plate, "/", row, "/", col, "/", file))
                    index <- rbind(index, tmp)
                }
            }
        }
    }
    colnames(index) <- c("plate", "well", "row", "col", "field", "path")

    cat("[INFO] Indexed ", nfiles, " image files\n")
    if (nfiles == 0) {
        warning("No files detected, suggest you check pattern is correct.")
    } else {
        rownames(index) <- paste0(index$plate, ":", index$well, ":", index$field)
    }


    return(index)
}

#-------------------------------------------------------------------------------
#' Read a binary matrix, used for reading the registration matrices
#'
#' @description
#' Adapted from: https://www.r-bloggers.com/2012/06/getting-numpy-data-into-r/
#'
#' @param path to binary matrix
#'
#' @export
tglow_read_binmat <- function(path) {
    con <- file(path, "rb")
    dim <- readBin(con, "integer", 2)
    mat <- matrix(readBin(con, "numeric", prod(dim)), dim[1], dim[2])
    close(con)
    return(mat)
}


#-------------------------------------------------------------------------------
#' Load images around the center of a cell object
#'
#'
#' @param dataset A \linkS4class{TglowDataset}
#' @param assay The assay to use
#' @param slot The slot to use for calculating filters, defaults to "data". Can be "data" or "scale.data"
#' @param cell.subset The subset of cells to retrieve
#' @param group.col The feature to match cells to img.index. Usually 'Metadata_group'
#' @param img.index A matrix with image paths generated by tglow.build.img.index
#' @param reg.index A matrix with registration paths generated by tglow.build.img.index
#' Must have an additional collumn named 'plate2' to indicate the registraiton plate
#' @param window Window in px around the cell center to retrieve
#' @param feature.x The feature that describes the object pos in px in x
#' @param feature.y The feature that describes the object pos in px in y
#' @param channels The channels to read. A list of Vector of indices per cycle. (default NULL = all channels)
#' @param planes The planes to read. A list of Vector of indices per cycle. (default NULL = all planes)
#' @param max.project Should the stack be max projected per channel? (default TRUE)
#'
#' importFrom EBImage colorMode affine combine Grayscale colorMode<-
#' importFrom RBioFormats read.image
#' @returns A list of EBImage objects by object id
#' @export
tglow_read_imgs <- function(dataset,
                            assay = "raw",
                            slot = "data",
                            cell.subset,
                            group.col,
                            img.index,
                            reg.index = NULL,
                            window = 75,
                            feature.x = "cell_AreaShape_Center_X",
                            feature.y = "cell_AreaShape_Center_Y",
                            channels = NULL,
                            planes = NULL,
                            max.project = T) {
    check_dataset_assay_slot(dataset, assay, slot)
    check_package("EBImage")
    check_package("RBioFormats")
    
    cur.cells <- slot(dataset@assays[[assay]], slot)

    if ((class(cell.subset) != "character") && (class(cell.subset) != "integer")) {
        stop("Cell.subset must be character or integer")
    }

    if (class(cell.subset) == "integer") {
        warning("cell.subset is integer, make sure the indices are properly matched to assay.")
        if (max(cell.subset) > nrow(cur.cells)) {
            stop("Index in cell.subset larger then number of rows in assay. Are you using the correct assay?")
        }
    }

    pb <- progress::progress_bar$new(format = "[INFO] Reading images [:bar] :current/:total (:percent) eta :eta", total = length(cell.subset))
    out <- lapply(cell.subset, function(i) {
        pb$tick()
        cur.group <- dataset@image.meta[dataset@image.ids[i], group.col]
        cur.img <- img.index[cur.group, ]
        x.pos <- cur.cells[i, feature.x]
        y.pos <- cur.cells[i, feature.y]

        # cat("[INFO] Reading ", cur.img, "\n")
        cx <- round((x.pos - window):(x.pos + window))
        cy <- round((y.pos - window):(y.pos + window))

        subset <- list(X = cx, Y = cy)

        if (!is.null(channels)) {
            if (class(channels) != "list") {
                stop("Channels must be a list with one numeric vector per cycle containing channel indices to load.")
            }
            subset[["C"]] <- channels[[1]]
        }

        if (!is.null(planes)) {
            if (class(planes) != "list") {
                stop("Planes must be a list with one numeric vector per cycle containing plane indices to load.")
            }
            subset[["Z"]] <- planes[[1]]
        }

        img <- RBioFormats::read.image(cur.img$path, normalize = F, subset = subset)
        EBImage::colorMode(img) <- EBImage::Grayscale

        # Append mutliple cycles
        if (!is.null(reg.index)) {
            cur.reg.index <- reg.index[reg.index$plate == cur.img$plate & reg.index$well == cur.img$well & reg.index$field == cur.img$field, ]

            for (p2 in 1:nrow(cur.reg.index)) {
                new.img <- img.index[paste0(
                    cur.reg.index[p2, "plate2"], ":",
                    cur.reg.index[p2, "well"], ":",
                    cur.reg.index[p2, "field"]
                ), ]

                if (!is.null(channels)) {
                    if (length(channels) != nrow(cur.reg.index) + 1) {
                        stop("Length of channel list does not match the number of cycles found in reg.index")
                    }
                    subset[["C"]] <- as.numeric(channels[[p2 + 1]])
                }

                if (!is.null(planes)) {
                    if (length(planes) != nrow(cur.reg.index) + 1) {
                        stop("Length of plane list does not match the number of cycles found in reg.index")
                    }
                    subset[["Z"]] <- planes[[p2 + 1]]
                }


                # Read the registration matrix
                reg <- tglowr::tglow_read_binmat(cur.reg.index[p2, "path"])

                tmp.img <- RBioFormats::read.image(new.img$path, subset = subset, normalize = F)
                EBImage::colorMode(tmp.img) <- EBImage::Grayscale

                # Recode the matrix so it works with EBImage
                m <- t(reg)[, 1:2]
                m[3, ] <- -1 * m[3, ]

                # Apply affine transform
                tmp.img <- EBImage::affine(tmp.img, m, filter = "none", antialias = F)

                # Combine with the image
                img <- EBImage::combine(img, tmp.img)
            }
        }

        crop <- img

        if (length(dim(img)) == 4) {
            # Max project
            if (max.project) {
                crop <- apply(img, c(1, 2, 3), max)
            }
        } else if (length(dim(img)) == 3) {
            # Max project
            if (max.project) {
                crop <- apply(img, c(1, 2), max)
            }
        } else if (length(dim(img)) == 2) {
            crop <- img
        }
        return(crop)
    })

    cat("\n")
    names(out) <- dataset@object.ids[cell.subset]

    return(out)
}

